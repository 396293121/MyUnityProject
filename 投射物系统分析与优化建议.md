# ğŸš€ æŠ•å°„ç‰©ç³»ç»Ÿæ·±åº¦åˆ†æä¸ä¼˜åŒ–å»ºè®®

## ğŸ“‹ **å½“å‰æŠ•å°„ç‰©ç³»ç»Ÿæ¦‚è§ˆ**

### ğŸ—ï¸ **ç³»ç»Ÿæ¶æ„**
```
SkillProjectile.cs (æ ¸å¿ƒç»„ä»¶)
â”œâ”€â”€ æŠ•å°„ç‰©é…ç½® (åŸºç¡€å±æ€§ã€è§†è§‰æ•ˆæœ)
â”œâ”€â”€ è¿è¡Œæ—¶çŠ¶æ€ (ä½ç½®ä¿¡æ¯ã€æˆ˜æ–—å±æ€§)
â”œâ”€â”€ æŠ•å°„ç‰©ç±»å‹ (Standard, DoT, Homing, AOE)
â”œâ”€â”€ ç¢°æ’æ£€æµ‹ç³»ç»Ÿ
â”œâ”€â”€ ä¼¤å®³åº”ç”¨ç³»ç»Ÿ
â””â”€â”€ è°ƒè¯•å·¥å…·
```

### ğŸ¯ **æŠ•å°„ç‰©ç±»å‹åˆ†æ**

#### 1. **Standard (æ ‡å‡†æŠ•å°„ç‰©)**
- âœ… **åŠŸèƒ½å®Œå–„**: ç§»åŠ¨ã€ç¢°æ’æ£€æµ‹ã€ä¼¤å®³åº”ç”¨
- âœ… **æ€§èƒ½è‰¯å¥½**: ç®€å•ç›´çº¿ç§»åŠ¨ï¼Œèµ„æºæ¶ˆè€—ä½
- âœ… **é€»è¾‘æ¸…æ™°**: OnTriggerEnter2D å¤„ç†ä¸€æ¬¡æ€§ä¼¤å®³

#### 2. **DoT (æŒç»­ä¼¤å®³æŠ•å°„ç‰©)** - ğŸ”§ **å·²ä¿®å¤**
- âŒ **åŸé—®é¢˜**: `currentDuration` å˜é‡æœªå®šä¹‰
- âŒ **åŸé—®é¢˜**: åç¨‹é€»è¾‘é”™è¯¯
- âŒ **åŸé—®é¢˜**: é‡å¤ä¼¤å®³æœªæ§åˆ¶
- âœ… **ä¿®å¤å**: å®Œæ•´çš„DoTç³»ç»Ÿï¼Œæ”¯æŒæŒç»­ä¼¤å®³å’Œåç¨‹ç®¡ç†

#### 3. **Homing (ç´¢æ•ŒæŠ•å°„ç‰©)** - âš ï¸ **æœªå®ç°**
- âŒ **ç¼ºå¤±**: `AcquireHomingTarget()` æ–¹æ³•æœªå®ç°
- âŒ **ç¼ºå¤±**: ç›®æ ‡è·Ÿè¸ªé€»è¾‘
- âŒ **ç¼ºå¤±**: è½¬å‘å’Œè¿½è¸ªç®—æ³•

#### 4. **AOE (èŒƒå›´ä¼¤å®³æŠ•å°„ç‰©)** - âš ï¸ **æœªå®ç°**
- âŒ **ç¼ºå¤±**: èŒƒå›´æ£€æµ‹é€»è¾‘
- âŒ **ç¼ºå¤±**: å¤šç›®æ ‡ä¼¤å®³å¤„ç†
- âŒ **ç¼ºå¤±**: çˆ†ç‚¸æ•ˆæœ

---

## ğŸ” **ApplyDoTDamage ä¿®æ”¹è¯¦è§£**

### ğŸš¨ **åŸå§‹é—®é¢˜**
```csharp
// âŒ é—®é¢˜ä»£ç 
private IEnumerator ApplyDoTDamage(GameObject target)
{
    while (currentDuration < damageInterval)  // currentDuration æœªå®šä¹‰
    {
        ApplyDamage(target);
        yield return new WaitForSeconds(damageInterval);
    }
}
```

### âœ… **ä¿®å¤æ–¹æ¡ˆ**
```csharp
// âœ… ä¿®å¤åä»£ç 
private IEnumerator ApplyDoTDamage(GameObject target)
{
    float elapsedTime = 0f;
    float totalDuration = maxDistance / speed; // åŸºäºæŠ•å°„ç‰©ç”Ÿå­˜æ—¶é—´
    
    while (elapsedTime < totalDuration && target != null)
    {
        ApplyDamage(target);
        yield return new WaitForSeconds(damageInterval);
        elapsedTime += damageInterval;
    }
    
    // æ¸…ç†åç¨‹è®°å½•
    if (activeDoTCoroutines.ContainsKey(target))
    {
        activeDoTCoroutines.Remove(target);
    }
}
```

### ğŸ¯ **å…³é”®æ”¹è¿›**
1. **æ—¶é—´ç®¡ç†**: ä½¿ç”¨ `elapsedTime` è¿½è¸ªå·²æ‰§è¡Œæ—¶é—´
2. **æŒç»­æ—¶é—´è®¡ç®—**: åŸºäºæŠ•å°„ç‰©é£è¡Œæ—¶é—´ `maxDistance / speed`
3. **ç©ºå¼•ç”¨ä¿æŠ¤**: æ£€æŸ¥ `target != null`
4. **èµ„æºæ¸…ç†**: åç¨‹ç»“æŸæ—¶æ¸…ç†å­—å…¸è®°å½•

---

## ğŸ”§ **ç³»ç»Ÿä¼˜åŒ–å»ºè®®**

### ğŸš€ **æ€§èƒ½ä¼˜åŒ–**

#### 1. **å¯¹è±¡æ± åŒ–**
```csharp
// å»ºè®®å®ç°æŠ•å°„ç‰©å¯¹è±¡æ± 
public class ProjectilePool : MonoBehaviour
{
    private Queue<SkillProjectile> projectilePool = new Queue<SkillProjectile>();
    
    public SkillProjectile GetProjectile()
    {
        if (projectilePool.Count > 0)
            return projectilePool.Dequeue();
        else
            return CreateNewProjectile();
    }
    
    public void ReturnProjectile(SkillProjectile projectile)
    {
        projectile.Reset();
        projectilePool.Enqueue(projectile);
    }
}
```

#### 2. **ç¢°æ’æ£€æµ‹ä¼˜åŒ–**
```csharp
// ä½¿ç”¨ LayerMask ä¼˜åŒ–ç¢°æ’æ£€æµ‹
[SerializeField] private LayerMask targetLayers = -1;

private bool ShouldHitTarget(GameObject target)
{
    // å…ˆæ£€æŸ¥å±‚çº§ï¼Œå†æ£€æŸ¥æ ‡ç­¾
    if ((targetLayers.value & (1 << target.layer)) == 0)
        return false;
        
    return target != owner &&
           (target.CompareTag("Enemy") && targetType == TargetType.Enemy) ||
           (target.CompareTag("Player") && targetType == TargetType.Self) ||
           (targetType == TargetType.All);
}
```

### ğŸ¯ **åŠŸèƒ½æ‰©å±•**

#### 1. **ç´¢æ•ŒæŠ•å°„ç‰©å®ç°**
```csharp
private void AcquireHomingTarget()
{
    if (currentTarget == null || !IsValidTarget(currentTarget))
    {
        FindNearestTarget();
    }
    
    if (currentTarget != null)
    {
        Vector3 direction = (currentTarget.transform.position - transform.position).normalized;
        transform.Translate(direction * speed * Time.deltaTime);
    }
}

private void FindNearestTarget()
{
    Collider2D[] targets = Physics2D.OverlapCircleAll(transform.position, homingRadius, targetLayers);
    float nearestDistance = float.MaxValue;
    
    foreach (var target in targets)
    {
        if (ShouldHitTarget(target.gameObject))
        {
            float distance = Vector3.Distance(transform.position, target.transform.position);
            if (distance < nearestDistance)
            {
                nearestDistance = distance;
                currentTarget = target.gameObject;
            }
        }
    }
}
```

#### 2. **AOEæŠ•å°„ç‰©å®ç°**
```csharp
private void ApplyAOEDamage()
{
    Collider2D[] targets = Physics2D.OverlapCircleAll(transform.position, aoeRadius, targetLayers);
    
    foreach (var target in targets)
    {
        if (ShouldHitTarget(target.gameObject))
        {
            ApplyDamage(target.gameObject);
        }
    }
    
    PlayAOEEffect();
}
```

### ğŸ›¡ï¸ **å®‰å…¨æ€§æ”¹è¿›**

#### 1. **ç©ºå¼•ç”¨ä¿æŠ¤**
```csharp
private void ApplyDamage(GameObject target)
{
    if (target == null) return;
    
    var damageable = target.GetComponent<IDamageable>();
    if (damageable != null)
    {
        damageable.TakeDamage((int)damage);
        
        if (!string.IsNullOrEmpty(hitSound))
        {
            PlayerAudioConfig.Instance?.PlaySound(hitSound);
        }
    }
}
```

#### 2. **ç»„ä»¶éªŒè¯å¢å¼º**
```csharp
private void ValidateProjectileSetup()
{
    if (projectileType == ProjectileType.DoT && damageInterval <= 0)
    {
        Debug.LogError("DoTæŠ•å°„ç‰©éœ€è¦è®¾ç½®æœ‰æ•ˆçš„ä¼¤å®³é—´éš”");
    }
    
    if (projectileType == ProjectileType.Homing && homingRadius <= 0)
    {
        Debug.LogError("ç´¢æ•ŒæŠ•å°„ç‰©éœ€è¦è®¾ç½®æœ‰æ•ˆçš„ç´¢æ•ŒåŠå¾„");
    }
}
```

### ğŸ“Š **æ•°æ®ç»“æ„ä¼˜åŒ–**

#### 1. **æŠ•å°„ç‰©æ•°æ®é…ç½®**
```csharp
[System.Serializable]
public class ProjectileConfig
{
    public ProjectileType type;
    public float speed;
    public float maxDistance;
    public float damage;
    public float damageInterval;
    public float homingRadius;
    public float aoeRadius;
    public GameObject impactEffect;
    public string hitSound;
}
```

#### 2. **çŠ¶æ€ç®¡ç†ä¼˜åŒ–**
```csharp
public enum ProjectileState
{
    Inactive,
    Flying,
    Homing,
    Exploding,
    DoTActive
}

private ProjectileState currentState = ProjectileState.Inactive;
```

---

## ğŸ® **ä½¿ç”¨å»ºè®®**

### ğŸ”§ **é…ç½®æœ€ä½³å®è·µ**

1. **æ ‡å‡†æŠ•å°„ç‰©**: é€‚ç”¨äºå¼“ç®­ã€é­”æ³•é£å¼¹ç­‰ä¸€æ¬¡æ€§ä¼¤å®³
2. **DoTæŠ•å°„ç‰©**: é€‚ç”¨äºæ¯’ç®­ã€ç‡ƒçƒ§å¼¹ç­‰æŒç»­ä¼¤å®³æ•ˆæœ
3. **ç´¢æ•ŒæŠ•å°„ç‰©**: é€‚ç”¨äºè¿½è¸ªå¯¼å¼¹ã€é­”æ³•è¿½è¸ªå¼¹
4. **AOEæŠ•å°„ç‰©**: é€‚ç”¨äºçˆ†ç‚¸ç®­ã€èŒƒå›´é­”æ³•

### âš¡ **æ€§èƒ½è€ƒè™‘**

1. **åŒæ—¶å­˜åœ¨çš„æŠ•å°„ç‰©æ•°é‡**: å»ºè®®ä¸è¶…è¿‡50ä¸ª
2. **DoTåç¨‹ç®¡ç†**: åŠæ—¶æ¸…ç†æ— æ•ˆåç¨‹
3. **ç¢°æ’æ£€æµ‹é¢‘ç‡**: ä½¿ç”¨åˆé€‚çš„ FixedUpdate é¢‘ç‡
4. **ç‰¹æ•ˆå®ä¾‹åŒ–**: è€ƒè™‘ç‰¹æ•ˆå¯¹è±¡æ± 

### ğŸ› **è°ƒè¯•æŠ€å·§**

1. **ä½¿ç”¨å†…ç½®è°ƒè¯•å·¥å…·**: `ShowProjectileInfo()`, `ValidateComponents()`
2. **Gizmosç»˜åˆ¶**: æ˜¾ç¤ºæŠ•å°„ç‰©è½¨è¿¹å’ŒèŒƒå›´
3. **æ—¥å¿—è®°å½•**: è®°å½•å…³é”®çŠ¶æ€å˜åŒ–
4. **æ€§èƒ½ç›‘æ§**: ç›‘æ§åç¨‹æ•°é‡å’Œå†…å­˜ä½¿ç”¨

---

## ğŸ“ˆ **æ€»ç»“**

### âœ… **å·²è§£å†³é—®é¢˜**
- âœ… DoTä¼¤å®³é€»è¾‘ä¿®å¤
- âœ… åç¨‹ç®¡ç†ä¼˜åŒ–
- âœ… èµ„æºæ¸…ç†æœºåˆ¶
- âœ… é‡å¤ä¼¤å®³æ§åˆ¶

### ğŸ”„ **å¾…å®ç°åŠŸèƒ½**
- ğŸ”² ç´¢æ•ŒæŠ•å°„ç‰©å®Œæ•´å®ç°
- ğŸ”² AOEæŠ•å°„ç‰©ç³»ç»Ÿ
- ğŸ”² å¯¹è±¡æ± åŒ–æœºåˆ¶
- ğŸ”² é«˜çº§ç‰¹æ•ˆç³»ç»Ÿ

### ğŸ¯ **ä¼˜åŒ–é‡ç‚¹**
1. **æ€§èƒ½**: å¯¹è±¡æ± åŒ–ã€ç¢°æ’ä¼˜åŒ–
2. **åŠŸèƒ½**: å®Œå–„ç´¢æ•Œå’ŒAOEç³»ç»Ÿ
3. **å®‰å…¨**: ç©ºå¼•ç”¨ä¿æŠ¤ã€ç»„ä»¶éªŒè¯
4. **æ‰©å±•**: æ¨¡å—åŒ–è®¾è®¡ã€é…ç½®ç³»ç»Ÿ

è¿™ä¸ªæŠ•å°„ç‰©ç³»ç»Ÿç°åœ¨å…·å¤‡äº†è‰¯å¥½çš„åŸºç¡€æ¶æ„ï¼Œé€šè¿‡æŒç»­ä¼˜åŒ–å¯ä»¥æ”¯æŒæ›´å¤æ‚çš„æ¸¸æˆç©æ³•éœ€æ±‚ã€‚